/*
 * Copyright (c) 2013 - 2015, Freescale Semiconductor, Inc.
 * Copyright 2016-2017 NXP
 * All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

#include "fsl_device_registers.h"
#include "fsl_debug_console.h"
#include "pin_mux.h"
#include "clock_config.h"
#include "board.h"
#include "fsl_dspi.h"

/*******************************************************************************
 * Definitions
 ******************************************************************************/


/*******************************************************************************
 * Prototypes
 ******************************************************************************/

/*******************************************************************************
 * Code
 ******************************************************************************/
void setupSPI()
{
	dspi_master_config_t masterConfig;
	/* Master config */

	masterConfig.whichCtar = kDSPI_Ctar0;
	masterConfig.ctarConfig.baudRate = 500000;
	masterConfig.ctarConfig.bitsPerFrame = 8U;
	masterConfig.ctarConfig.cpol =
	kDSPI_ClockPolarityActiveHigh;
	masterConfig.ctarConfig.cpha = kDSPI_ClockPhaseFirstEdge;
	masterConfig.ctarConfig.direction = kDSPI_MsbFirst;
	masterConfig.ctarConfig.pcsToSckDelayInNanoSec = 1000000000U / 500000;
	masterConfig.ctarConfig.lastSckToPcsDelayInNanoSec = 1000000000U / 500000;
	masterConfig.ctarConfig.betweenTransferDelayInNanoSec = 1000000000U / 500000;

	masterConfig.whichPcs = kDSPI_Pcs0;
	masterConfig.pcsActiveHighOrLow = kDSPI_PcsActiveLow;

	masterConfig.enableContinuousSCK = false;
	masterConfig.enableRxFifoOverWrite = false;
	masterConfig.enableModifiedTimingFormat = false;
	masterConfig.samplePoint = kDSPI_SckToSin0Clock;

	DSPI_MasterInit(SPI1, &masterConfig, BUS_CLK);
}

void voltageRegulatorEnable()
{
	gpio_pin_config_t pin_config = {
	.pinDirection = kGPIO_DigitalOutput,
	.outputLogic = 0U};
	GPIO_PinInit(GPIOB, 8, &pin_config);
	GPIO_PinWrite(GPIOB, 8, 1U);
}

void accelerometerEnable()
{
	gpio_pin_config_t pin_config = {
	.pinDirection = kGPIO_DigitalOutput,
	.outputLogic = 0U};
	GPIO_PinInit(GPIOA, 25, &pin_config);
	GPIO_PinWrite(GPIOA, 25, 0U);
}

status_t SPI_read(uint8_t regAddress, uint8_t *rxBuff, uint8_t rxBuffSize)
{
	dspi_transfer_t masterXfer;
	uint8_t *masterTxData = (uint8_t*)malloc(rxBuffSize + 2);
	uint8_t *masterRxData = (uint8_t*)malloc(rxBuffSize + 2);

	masterTxData[0] = regAddress & 0x7F; //Clear the most significant bit
	masterTxData[1] = regAddress & 0x80; //Clear the least significant 7 bits

	masterXfer.txData = masterTxData;
	masterXfer.rxData = masterRxData;
	masterXfer.dataSize = rxBuffSize + 2;
	masterXfer.configFlags = kDSPI_MasterCtar0 | kDSPI_MasterPcs0 |
	kDSPI_MasterPcsContinuous;
	status_t ret = DSPI_MasterTransferBlocking(SPI1, &masterXfer);
	memcpy(rxBuff, &masterRxData[2], rxBuffSize);

	free(masterTxData);
	free(masterRxData);

	return ret;
}

//write value to the regsiter at regAddress
status_t SPI_write(uint8_t regAddress, uint8_t value) {

	dspi_transfer_t masterXfer; //the transfer buffer
	uint8_t *masterTxData = (uint8_t*)malloc(sizeof(value) + 2);
	uint8_t *masterRxData = (uint8_t*)malloc(sizeof(value) + 2);

	//BYTE 1 = COMMAND BYTE 0:
	//BYTE 2 = COMM BYTE 1:
	//Address is 8 bits total, split across 2 bytes

    masterTxData[0] = (regAddress & 0x7F) | 0x80;   // Set MSB = WRITE, setting the MSB byte of byte 0 to send as a write, lower bits are address[6:0]
    masterTxData[1] = regAddress & 0x80;   // extract MSB and put it into the second byte, lower bits are 0s

    memcpy(&masterTxData[2], &value, sizeof(value));

    masterXfer.txData = masterTxData;
    masterXfer.rxData = masterRxData;      // RX ignored
    masterXfer.dataSize = sizeof(value) + 2;

	masterXfer.configFlags =
    kDSPI_MasterCtar0 |
    kDSPI_MasterPcs0 |
    kDSPI_MasterPcsContinuous;

	PRINTF("SPI_Write writing to register %x, writing value %d\n", regAddress, masterTxData[2]);

	status_t ret = DSPI_MasterTransferBlocking(SPI1, &masterXfer);

	free(masterTxData);
	free(masterRxData);
	return ret;

}

/*!
 * @brief Main function
 */
int main(void)
{
	uint8_t byte;
	/* Init board hardware. */
	BOARD_InitBootPins();
	BOARD_InitBootClocks();
	BOARD_InitDebugConsole();

	setupSPI();
	voltageRegulatorEnable();
	accelerometerEnable();

	/******* Delay *******/
	for(volatile int i = 0U; i < 1000000; i++)
		__asm("NOP");

	SPI_read(0x0D, &byte, 1); //WHO_AM_I register
	printf("The expected value is 0xC7 and the read value 0x%X\n", byte);

	//testing by adjusting the OFF_X register (R/W reg for X-axis accelerometer offset adjust)
	SPI_write(0x2F, 1);
	printf("Writing value of OFF_X register to\n", 1);

	//to see if changed to 1, use SPI_read on this register
	SPI_read(0x2F, &byte, 1);
	printf("Test: Register OFF_X value changed from 0x00 to %d\n", 1);

	while (1)
	{
	}
}
